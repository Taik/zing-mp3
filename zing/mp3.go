package zing

import (
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/PuerkitoBio/goquery"
	"github.com/Taik/zing-mp3/tags"
	"gopkg.in/inconshreveable/log15.v2"
)

var (
	// Logger is the logger instance to be used throughout the package
	Logger = log15.New()

	errNoPlayerFound = errors.New("no HTML5 player instance found")
	errInvalidURL    = errors.New("invalid url")
)

func init() {
	// Initializes logger to throw away all messages by default
	Logger.SetHandler(log15.DiscardHandler())
}

// AlbumItem represents each item in Album.
type AlbumItem struct {
	Title       string `xml:"title"`
	Artist      string `xml:"performer"`
	ItemURL     string `xml:"link"`
	DownloadURL string `xml:"source"`
	LyricURL    string `xml:"lyric"`
}

// Album represents a Zing MP3 player source.
type Album struct {
	XMLName xml.Name    `xml:"data"`
	Items   []AlbumItem `xml:"item"`
}

// Name returns a filename generated by concatening Artist and Title together.
func (i *AlbumItem) Name() string {
	return fmt.Sprintf("%s - %s.mp3",
		strings.TrimSpace(i.Artist),
		strings.TrimSpace(i.Title),
	)
}

// ParseAlbumData parses a zing MP3 URL and returns a Album associated with the current player on the page.
func ParseAlbumData(zingURL string) (*Album, error) {
	if zingURL == "" {
		Logger.Error("Invalid album data URL",
			"zing_url", zingURL,
		)
		return nil, errInvalidURL
	}
	Logger.Debug("Parsing for album data URL",
		"zing_url", zingURL,
	)

	doc, err := goquery.NewDocument(zingURL)
	if err != nil {
		return nil, err
	}

	dataXMLURL, found := doc.Find("div#html5player").Attr("data-xml")
	if found == false {
		return nil, errNoPlayerFound
	}

	Logger.Debug("Found zing album data URL",
		"album_data_xml", dataXMLURL,
	)
	response, err := http.Get(dataXMLURL)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	album := &Album{}
	err = xml.NewDecoder(response.Body).Decode(album)
	if err != nil {
		return nil, err
	}

	return album, nil
}

// DownloadAlbum initializes
func DownloadAlbum(zingURL, downloadDir string) error {
	album, err := ParseAlbumData(zingURL)
	if err != nil {
		Logger.Error("Unable to parse album data",
			"album_url", zingURL,
			"error", err,
		)
		return nil
	}

	Logger.Debug("Found items to download",
		"item_count", len(album.Items),
		"album_url", zingURL,
	)

	wg := &sync.WaitGroup{}
	wg.Add(len(album.Items))

	for _, v := range album.Items {
		go func(item AlbumItem) {
			defer wg.Done()
			Logger.Info("Processing item",
				"artist", item.Artist,
				"title", item.Title,
				"download_url", item.DownloadURL,
			)

			Logger.Debug("Downloading item", "download_url", item.DownloadURL)
			fd, err := DownloadAlbumItem(&item, downloadDir)
			if err != nil {
				Logger.Error("Could not download item", "error", err)
			} else {
				Logger.Debug("File downloaded", "file_path", fd.Name())
			}

			Logger.Debug("Updating mp3 tags", "file_path", fd.Name())
			err = tags.UpdateMP3Tags(fd, item.Artist, item.Title)
			if err != nil {
				Logger.Error("Could not update mp3 tags", "file_path", fd.Name())
			} else {
				Logger.Debug("File mp3 tag updated", "file_path", fd.Name())
			}

			Logger.Info("Item complete",
				"artist", item.Artist,
				"title", item.Title,
				"file_path", fd.Name(),
			)
		}(v)
	}

	wg.Wait()
	return nil
}

// DownloadAlbumItem fetches the song from DownloadURL and returns an os.File which represents the file on-disk.
func DownloadAlbumItem(item *AlbumItem, downloadDir string) (*os.File, error) {
	os.Mkdir(downloadDir, os.ModePerm)

	response, err := http.Get(item.DownloadURL)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	fd, err := os.Create(filepath.Join(downloadDir, item.Name()))
	if err != nil {
		return nil, err
	}
	io.Copy(fd, response.Body)
	return fd, nil
}
